import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.signal import spectrogram
from scipy import signal
import obspy
import math
from obspy.core import UTCDateTime
import datetime
from obspy.geodetics import gps2dist_azimuth
from prelude import make_base_dir, distance
import datetime
from obspy import UTCDateTime

def closest_encounter(flight_latitudes, flight_longitudes, index, timestamp, seismo_latitude, seismo_longitude):
	def calculate_distance(lat1, lon1, lat2, lon2):
		_, _, distance = gps2dist_azimuth(lat1, lon1, lat2, lon2)
		return distance

	def calculate_projection(line_vector, station_vector):
		dot_product = line_vector[0] * station_vector[0] + line_vector[1] * station_vector[1]
		line_magnitude_squared = line_vector[0] ** 2 + line_vector[1] ** 2
		projection_length_ratio = dot_product / line_magnitude_squared
		return projection_length_ratio

	closest_distance = float('inf')
	closest_lat = flight_latitudes[index]
	closest_lon = flight_longitudes[index]

	for i in [index-1, index+1]:
		if i >= 0 and i < len(flight_latitudes):
			distance = calculate_distance(flight_latitudes[i], flight_longitudes[i], seismo_latitude, seismo_longitude)
			if distance < closest_distance:
				closest_distance = distance
				closest_lat = flight_latitudes[i]
				closest_lon = flight_longitudes[i]

	line_vector = (flight_latitudes[index] - closest_lat, flight_longitudes[index] - closest_lon)
	station_vector = (seismo_latitude - closest_lat, seismo_longitude - closest_lon)

	projection_length_ratio = calculate_projection(line_vector, station_vector)

	closest_point_on_line_lat = closest_lat + projection_length_ratio * line_vector[0]
	closest_point_on_line_lon = closest_lon + projection_length_ratio * line_vector[1]

	closest_distance = calculate_distance(closest_point_on_line_lat, closest_point_on_line_lon, seismo_latitude, seismo_longitude)

	return closest_distance
def calc_f(f0, t, l, v0):
	#t is epoch time at time wave is generated by aircraft sec
	#l is the shortest distance to between the station and aircraft km
	#v0 is the aircraft velocity km/sec
	#c is the speed of acoustic wave propagation km/sec
	c = 0.343 #km/sec
	tprime = t+(math.sqrt(l**2+(v0*t)**2))/c
	f = f0*(1/(1+(v0/c)*(v0*tprime/(np.sqrt(l**2+(v0*tprime)**2)))))
	
	return f,tprime


seismo_data = pd.read_csv('input/all_sta.txt', sep="|")
seismo_latitudes = seismo_data['Latitude']
seismo_longitudes = seismo_data['Longitude']
station = seismo_data['Station']
flight_num = [530342801,528485724,528473220,528407493,528293430]
time = [1551066051,1550172833,1550168070,1550165577,1550089044]
sta = [1022,1272,1173,1283,1004]
day = [25,14,14,14,13]
for n in range(0,5):
	ht = datetime.datetime.utcfromtimestamp(time[n])
	mins = ht.minute
	secs = ht.second
	h = ht.hour
	tim = 120	
	h_u = str(h+1)
	if h < 23:			
		day2 = str(day[n])
		if h < 10:
			h_u = '0'+str(h+1)
			h = '0'+str(h)
		else:
			h_u = str(h+1)
			h = str(h)
	else:
		h_u = '00'
		day2 = str(day[n]+1)
	flight_data = pd.read_csv('/scratch/irseppi/nodal_data/flightradar24/201902'+str(day[n])+'_positions/201902'+str(day[n])+'_'+str(flight_num[n])+'.csv', sep=",")

	flight_latitudes = flight_data['latitude']
	flight_longitudes = flight_data['longitude']
	tm = flight_data['snapshot_id']
	speed = flight_data['speed']
	alt = flight_data['altitude']
	head = flight_data['heading']
	for line in range(len(tm)):
		if str(tm[line]) == str(time[n]):
			speed = flight_data['speed'][line]
			alt = flight_data['altitude'][line]
			for y in range(len(station)):
				if str(station[y]) == str(sta[n]):
					dist = distance(seismo_latitudes[y], seismo_longitudes[y], flight_latitudes[line], flight_longitudes[line])	

					p = "/scratch/naalexeev/NODAL/2019-02-"+str(day[n])+"T"+str(h)+":00:00.000000Z.2019-02-"+day2+"T"+h_u+":00:00.000000Z."+station[y]+".mseed"
					tr = obspy.read(p)
					tr[2].trim(tr[2].stats.starttime + (mins * 60) + secs - tim, tr[2].stats.starttime + (mins * 60) + secs + tim)
					data = tr[2][0:-1]
					fs = int(tr[2].stats.sampling_rate)
					title = f'{tr[2].stats.network}.{tr[2].stats.station}.{tr[2].stats.location}.{tr[2].stats.channel} âˆ’ starting {tr[2].stats["starttime"]}'						
					t = tr[2].times()
					# Time array
					t = np.arange(len(data)) / fs
					g = fs*240
					# Compute spectrogram
					frequencies, times, Sxx = spectrogram(data, fs, scaling='density', nperseg=fs, noverlap=fs * .9, detrend = 'constant') 

					a, b = Sxx.shape

					MDF = np.zeros((a,b))
					for row in range(len(Sxx)):
						m = len(Sxx[row])
						p = sorted(Sxx[row])
						median = p[int(m/2)]
						for col in range(m):
							MDF[row][col] = median
					fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True, figsize=(8,6))     

					ax1.plot(t, data, 'k', linewidth=0.5)
					ax1.set_title(title)
					ax1.axvline(x=tim, c = 'r', ls = '--')
					ax1.margins(x=0)

					spec = 10 * np.log10(Sxx) - (10 * np.log10(MDF))
					# Find the index of the middle frequency
					middle_index = len(times) // 2
					middle_column = spec[:, middle_index]
					vmin = 0  
					vmax = np.max(middle_column) 

					# Plot spectrogram
					cax = ax2.pcolormesh(times, frequencies, spec, shading='gouraud', cmap='pink_r', vmin=vmin, vmax=vmax)				
					ax2.set_xlabel('Time [s]')
					# Find the center of the trace
					center_index = len(data) // 2
					center_time = t[center_index]
					peaks, _ = signal.find_peaks(middle_column, prominence=20)
					largest_peak_index = np.argmax(middle_column[peaks])
					f0 = middle_column[peaks][largest_peak_index]
					freq1 = []
					time1 = []

					l = closest_encounter(flight_latitudes, flight_longitudes,line, tm, seismo_latitudes[y], seismo_longitudes[y])
					current_time = tr[2].stats.starttime + (mins * 60) + secs - tim
					time_after = tr[2].stats.starttime + (mins * 60) + secs + tim
					while current_time <= time_after:
						# Convert ObsPy time to timestamp
						current_time = UTCDateTime(current_time)
						t = current_time.datetime.timestamp()

						vo = (speed)*0.000514444

						frequency,ptime = calc_f(f0,t, l, vo) 
						freq1.append(frequency)  # Change variable name 'f' to 'frequency'
						time1.append(ptime)
						# Increment to the next second
						current_time += datetime.timedelta(seconds=1)
					
					ax2.plot(time1, freq1, 'r.', linewidth=0.5)
					ax2.axvline(x=center_time, c = 'k', ls = '--')
					ax2.set_ylabel('Frequency (Hz)')
					ax2.margins(x=0)
					ax2.set_xlim(0, 240)
					ax3 = fig.add_axes([0.9, 0.11, 0.015, 0.35])

					plt.colorbar(mappable=cax, cax=ax3)
					ax3.set_ylabel('Relative Amplitude (dB)')

					make_base_dir('/scratch/irseppi/nodal_data/Plane_map_spec/')
					fig.savefig('/scratch/irseppi/nodal_data/pec_'+str(t)+'_'+str(sta[n])+'_'+str(flight_num[n])+'.png')
					
					plt.close()
									
