import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.signal import spectrogram
from scipy import signal
import obspy
import math
from obspy.core import UTCDateTime
import datetime
from obspy.geodetics import gps2dist_azimuth
from prelude import make_base_dir, distance
import datetime
from obspy import UTCDateTime



def closest_encounter(flight_latitudes, flight_longitudes, index, timestamp, seismo_latitude, seismo_longitude):
	def calculate_distance(lat1, lon1, lat2, lon2):
		_, _, distance = gps2dist_azimuth(lat1, lon1, lat2, lon2)
		return distance

	def calculate_projection(line_vector, station_vector):
		dot_product = line_vector[0] * station_vector[0] + line_vector[1] * station_vector[1]
		line_magnitude_squared = line_vector[0] ** 2 + line_vector[1] ** 2
		projection_length_ratio = dot_product / line_magnitude_squared
		return projection_length_ratio

	closest_distance = float('inf')
	closest_lat = flight_latitudes[index]
	closest_lon = flight_longitudes[index]

	for i in [index-1, index+1]:
		if i >= 0 and i < len(flight_latitudes):
			distance = calculate_distance(flight_latitudes[i], flight_longitudes[i], seismo_latitude, seismo_longitude)
			if distance < closest_distance:
				closest_distance = distance
				closest_lat = flight_latitudes[i]
				closest_lon = flight_longitudes[i]

	line_vector = (flight_latitudes[index] - closest_lat, flight_longitudes[index] - closest_lon)
	station_vector = (seismo_latitude - closest_lat, seismo_longitude - closest_lon)

	projection_length_ratio = calculate_projection(line_vector, station_vector)

	closest_point_on_line_lat = closest_lat + projection_length_ratio * line_vector[0]
	closest_point_on_line_lon = closest_lon + projection_length_ratio * line_vector[1]

	closest_distance = calculate_distance(closest_point_on_line_lat, closest_point_on_line_lon, seismo_latitude, seismo_longitude)

	return closest_distance *1000
def calc_f(f0, t, l, v0):
	#t is epoch time at time wave is generated by aircraft sec
	#l is the shortest distance to between the station and aircraft m
	#v0 is the aircraft velocity m/sec
	#c is the speed of acoustic wave propagation m/sec
	c = 343 #m/sec
	tflight = t-(np.sqrt(t**2-(1-v0**2/c**2)*(t**2-l**2/c**2)))/(1-v0**2/c**2)
	f = f0*(1/(1+(v0/c)*(v0*tflight/(np.sqrt(l**2+(v0*tflight)**2)))))

	return f,t


seismo_data = pd.read_csv('input/all_sta.txt', sep="|")
seismo_latitudes = seismo_data['Latitude']
seismo_longitudes = seismo_data['Longitude']
station = seismo_data['Station']
flight_num = [530342801,528485724,528473220,528407493,528293430]
time = [1551066051,1550172833,1550168070,1550165577,1550089044]
sta = [1022,1272,1173,1283,1004]
day = [25,14,14,14,13]
for n in range(0,5):
	ht = datetime.datetime.utcfromtimestamp(time[n])
	mins = ht.minute
	secs = ht.second
	h = ht.hour
	tim = 120	
	h_u = str(h+1)
	if h < 23:			
		day2 = str(day[n])
		if h < 10:
			h_u = '0'+str(h+1)
			h = '0'+str(h)
		else:
			h_u = str(h+1)
			h = str(h)
	else:
		h_u = '00'
		day2 = str(day[n]+1)
	flight_data = pd.read_csv('/scratch/irseppi/nodal_data/flightradar24/201902'+str(day[n])+'_positions/201902'+str(day[n])+'_'+str(flight_num[n])+'.csv', sep=",")

	flight_latitudes = flight_data['latitude']
	flight_longitudes = flight_data['longitude']
	tm = flight_data['snapshot_id']
	speed = flight_data['speed']
	alt = flight_data['altitude']
	head = flight_data['heading']
	for line in range(len(tm)):
		if str(tm[line]) == str(time[n]):
			speed = flight_data['speed'][line]
			alt = flight_data['altitude'][line]
			for y in range(len(station)):
				if str(station[y]) == str(sta[n]):
					dist = distance(seismo_latitudes[y], seismo_longitudes[y], flight_latitudes[line], flight_longitudes[line])	

					p = "/scratch/naalexeev/NODAL/2019-02-"+str(day[n])+"T"+str(h)+":00:00.000000Z.2019-02-"+day2+"T"+h_u+":00:00.000000Z."+station[y]+".mseed"
					tr = obspy.read(p)
					tr[2].trim(tr[2].stats.starttime + (mins * 60) + secs - tim, tr[2].stats.starttime + (mins * 60) + secs + tim)
					data = tr[2][0:-1]
					fs = int(tr[2].stats.sampling_rate)
					title = f'{tr[2].stats.network}.{tr[2].stats.station}.{tr[2].stats.location}.{tr[2].stats.channel} âˆ’ starting {tr[2].stats["starttime"]}'						
					t = tr[2].times()
					# Time array
					t = np.arange(len(data)) / fs
					g = fs*240
					# Compute spectrogram
					frequencies, times, Sxx = spectrogram(data, fs, scaling='density', nperseg=fs, noverlap=fs * .9, detrend = 'constant') 

					a, b = Sxx.shape

					MDF = np.zeros((a,b))
					for row in range(len(Sxx)):
						m = len(Sxx[row])
						p = sorted(Sxx[row])
						median = p[int(m/2)]
						for col in range(m):
							MDF[row][col] = median
					fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True, figsize=(8,6))     

					ax1.plot(t, data, 'k', linewidth=0.5)
					ax1.set_title(title)
					ax1.axvline(x=tim, c = 'r', ls = '--')
					ax1.margins(x=0)

					spec = 10 * np.log10(Sxx) - (10 * np.log10(MDF))
					# Find the index of the middle frequency
					middle_index = len(times) // 2
					middle_column = spec[:, middle_index]
					vmin = 0  
					vmax = np.max(middle_column) 
					
					# Plot spectrogram
					cax = ax2.pcolormesh(times, frequencies, spec, shading='gouraud', cmap='pink_r', vmin=vmin, vmax=vmax)				
					ax2.set_xlabel('Time [s]')
				
					freq1 = []
					time1 = []

					l = closest_encounter(flight_latitudes, flight_longitudes,line, tm, seismo_latitudes[y], seismo_longitudes[y])
					start_time = tr[2].stats.starttime + (mins * 60) + secs - tim
					# Convert ObsPy time to timestamp
					start_time = UTCDateTime(start_time)
					start_time= start_time.datetime.timestamp()

					end_time = tr[2].stats.starttime + (mins * 60) + secs + tim
					end_time  = UTCDateTime(end_time)
					end_time = end_time.datetime.timestamp()
					x_values = []
					y_values = []
					for gg in range(len(times)):
						column = spec[50:250, gg]
						
						tnew = times[gg]
					
						peaks, _ = signal.find_peaks(column, prominence=10)
						#largest_peak_index = np.argmax(column[peaks])
						#print(largest_peak_index)
						
						np.diff(peaks)
			
						largest_peak_index = np.argmax(column[peaks])
						#print(peaks[largest_peak_index])

						# Scatter plot
						ax2.scatter(tnew, peaks[largest_peak_index]+50, marker='x', color='k', linewidth=0.5)
					
						freq1.append(peaks[largest_peak_index]+50)
						time1.append(tnew)
					
					#ax2.axvline(x=center_time, c = 'k', ls = '--')
					ax2.set_ylabel('Frequency (Hz)')
					ax2.margins(x=0)
					ax2.set_xlim(0, 240)
					ax3 = fig.add_axes([0.9, 0.11, 0.015, 0.35])

					plt.colorbar(mappable=cax, cax=ax3)
					ax3.set_ylabel('Relative Amplitude (dB)')
					plt.show()
					# v0 = speed * 0.514444
					# c = 343 
					#freqtrue = []
					# freq1 = np.array(freq1)
					# time1 = [t - start_time for t in time1]
					# time1 = np.array(time1)
					# tt = np.arange(0, 240, 0.10041841004)
					# Vectorized calculations
					# tflight = (tt - (np.sqrt(tt**2 - (1 - v0**2 / c**2) * (tt**2 - l**2 / c**2)))) / (1 - v0**2 / c**2)

					# true_freq = freq1 * (1 + (v0 / c) * (v0 * tflight / np.sqrt(l**2 + (v0 * tflight)**2)))
					# f0 = np.mean(true_freq)

					# Vectorized calculations for observed_freq and tprime
					# times = np.array([t - start_time for t in times])

					#tt = np.arange(0, 240, 1)
					# f, tp = calc_f(f0, tt, l, v0)
				
					# for hh in range(len(freq1)):
					#     fobs = freq1[hh]
					#     tflight = time1[hh]-(np.sqrt(time1[hh]**2-(1-v0**2/c**2)*(time1[hh]**2-l**2/c**2)))/(1-v0**2/c**2)
					#     true_freq = fobs * (1+(v0/c)*(v0*tflight/(np.sqrt(l**2+(v0*tflight)**2))))
					#     freqtrue.append(true_freq)
					# f0 = np.sum(freqtrue)/len(freqtrue)
					# print(f0)
					# observed_freq = []
					# tprime = []
					# for ttt in times:
					#     f,tp = calc_f(f0, ttt, l, v0)
					#     observed_freq.append(f)
					#     tprime.append(tp)

					# Plot Doppler shift
					# plt.figure()
					# plt.scatter(tp, f)
					# plt.xlabel('Time [s]')
					# plt.ylabel('Doppler Shift [Hz]')
					# plt.title('Doppler Shift of Primary Overtone')
					# plt.ylim(0,250)
					# plt.show()
					# Save the figure
					#make_base_dir('/scratch/irseppi/nodal_data/Plane_map_spec/')
					#fig.savefig('/scratch/irseppi/nodal_data/pec_'+str(t)+'_'+str(sta[n])+'_'+str(flight_num[n])+'.png')
					
					#plt.close()
					
					# Convert lists to numpy arrays

					# Assume you have a spectrogram stored in the variable `S`
					plt.pcolormesh(times, frequencies, spec, shading='gouraud', cmap='pink_r', vmin=vmin, vmax=vmax)
					#plt.imshow(spec.T, aspect='auto')

					coords = []

					def onclick(event):
						global coords
						coords.append((event.xdata, event.ydata))
						plt.scatter(event.xdata, event.ydata, color='red')  # Add this line
						plt.draw() 
						print('Clicked:', event.xdata, event.ydata)  # Add this line
					cid = plt.gcf().canvas.mpl_connect('button_press_event', onclick)

					plt.show(block=True)
					# Convert the list of coordinates to a numpy array
					coords_array = np.array(coords)

					# Save the coordinates to a text file
					np.savetxt('coords_'+str(flight_num[n])+'.txt', coords_array)